
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Introduction &#8212; Cédric&#39;s book</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet" />
  <link href="../_static/css/index.c5995385ac14fb8791e8eb36b4908be2.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.1c5a1a01449ed65a7b51.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script>
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Famille des modèles paramétriques" href="file_01.html" />
    <link rel="prev" title="Apprentisage automatique supervisé" href="chapter_00_intro.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
      
      
      <h1 class="site-logo" id="site-title">Cédric's book</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../landing-page.html">
   Table of content
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="chapter_00_intro.html">
   Apprentisage automatique supervisé
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     Introduction
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="file_01.html">
     Famille des modèles paramétriques
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="file_02.html">
     Famille des modèles non-paramétriques
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="file_03.html">
     Recherche des hyperparamètres
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="file_04.html">
     Gestion des variables catégorielles
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../chapter_99/chapter_99_intro.html">
   Real-world examples
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../chapter_99/file_00.html">
     Analyse de statistique tradionnelle
    </a>
   </li>
  </ul>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/chapter_00/file_00.py"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.py</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#motivations-de-l-apprentissage-automatique">
   Motivations de l’apprentissage automatique
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction-a-l-interface-de-programmation-de-scikit-learn">
   Introduction à l’interface de programmation de
   <code class="docutils literal notranslate">
    <span class="pre">
     scikit-learn
    </span>
   </code>
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#evaluation-de-notre-modele-predictif">
   Evaluation de notre modèle prédictif
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h1>
<div class="section" id="motivations-de-l-apprentissage-automatique">
<h2>Motivations de l’apprentissage automatique<a class="headerlink" href="#motivations-de-l-apprentissage-automatique" title="Permalink to this headline">¶</a></h2>
<p>Avant de rentrer dans le vive du sujet et découvrir les différents modèles
d’apprentissage automatique disponibles dans <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code>, il advient de
motiver l’usage de telles techniques.</p>
<p>Nous pouvons d’ores et déjà définir ce que nous appelerons un modèle
prédictif. Un modèle prédictif correspond à une fonction prenant des données
en entrée est capable de renvoyé une prédiction en sortie. Mathématiquement,
nous pouvons exprimer un tel modèle comme suit :</p>
<div class="math notranslate nohighlight">
\[
\hat{y} = f(X) \,
\]</div>
<p>ou <span class="math notranslate nohighlight">\(X\)</span> seront nos <strong>données d’entrée</strong>, <span class="math notranslate nohighlight">\(f()\)</span> est notre <strong>modèle prédictif</strong>
et <span class="math notranslate nohighlight">\(\hat{y}\)</span> seront nos <strong>prédictions</strong>.</p>
<p>Nous pouvons donner un exemple concret dès maintenant. Nous allons charger un
jeu de données minimaliste.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="n">donnees</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s2">&quot;../datasets/penguins_regression.csv&quot;</span><span class="p">)</span>
<span class="n">donnees</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Longueur Aileron (mm)</th>
      <th>Masse Corporelle (g)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>181.0</td>
      <td>3750.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>186.0</td>
      <td>3800.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>195.0</td>
      <td>3250.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>193.0</td>
      <td>3450.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>190.0</td>
      <td>3650.0</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Nous venons de charger en mémoire des données contenant des informations
de pingouins. Ce jeu de données contient deux informations : pour chaque
pingouin, nous connaissons la longeur de son aileron ainsi que sa masse
corporelle.</p>
<p>Nous pouvons formuler le problème de prédiction suivant : à partir de ces
données, nous souhaitons apprendre une fonction <span class="math notranslate nohighlight">\(f()\)</span> qui prend en entrée
la longueur d’aileron d’un pingouin et qui renvoie sa masse corporelle.</p>
<p>Nous pouvons dès à présent visualiser ces données.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">seaborn</span> <span class="k">as</span> <span class="nn">sns</span>

<span class="n">sns</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="s2">&quot;poster&quot;</span><span class="p">)</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">donnees</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">donnees</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">donnees</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Peut-on prédire la masse corporelle </span><span class="se">\n</span><span class="s2">d&#39;un pingouin?&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/file_00_3_0.png" src="../_images/file_00_3_0.png" />
</div>
</div>
<p>En oberservant nos données, nous pouvons constater que nous avons un jeu de
données contenant à la fois l’entrée et la sortie de notre fonction <span class="math notranslate nohighlight">\(f()\)</span>.
Typiquement, ceci est le cas lorsque nous sommes dans un contexte
d’<strong>apprentissage supervisé</strong>.</p>
<p>L’idée sera de trouver la fonction <span class="math notranslate nohighlight">\(f()\)</span> optimale à partir de ces données
d’entrée et sortie. Par la suite, nous utiliserons cette fonction pour
prédire la sortie à partir d’une nouvelle donnée d’entrée.</p>
<p>Dans <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code>, les données d’entrée et de sortie sont séparées en deux
tableaux distincts, dénotés <code class="docutils literal notranslate"><span class="pre">X</span></code> et <code class="docutils literal notranslate"><span class="pre">y</span></code> dans la documentation.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">donnees</span><span class="p">[[</span><span class="s2">&quot;Longueur Aileron (mm)&quot;</span><span class="p">]]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">donnees</span><span class="p">[</span><span class="s2">&quot;Masse Corporelle (g)&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>Nous allons nous attarder sur la structure de ces données.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">X</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Longueur Aileron (mm)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>181.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>186.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>195.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>193.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>190.0</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">X</span></code> est représenté par une <strong>matrice</strong> de données en deux dimensions. Chaque
ligne correspond à un <strong>échantillon</strong> (i.e. un pingouin) et chaque colonne
correspond à une <strong>variable</strong> (i.e. une mesure physique). Dans notre jeu de
données minimaliste, nous avons une seule variable d’entrée, <code class="docutils literal notranslate"><span class="pre">Longueur</span> <span class="pre">Aileron</span> <span class="pre">(mm)</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0    3750.0
1    3800.0
2    3250.0
3    3450.0
4    3650.0
Name: Masse Corporelle (g), dtype: float64
</pre></div>
</div>
</div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">y</span></code> est représenté par un <strong>vecteur</strong> de données (i.e. une seul dimension).
Nous avons autant d’éléments que de lignes dans <code class="docutils literal notranslate"><span class="pre">X</span></code>. Cette variable est
communemment appellée <strong>variable cible</strong>.</p>
<p>Il important de noter que <code class="docutils literal notranslate"><span class="pre">y</span></code> est une variable continue : elle peut prendre
n’importe quel valeur entre moins l’infini et plus l’infini ou quasiment
(nous somme limités par la physique puisque le masse corporelle d’un pingouin
ne peut-être négative et trop grande). Lorsque <code class="docutils literal notranslate"><span class="pre">y</span></code> est une <strong>variable
continue</strong> nous appelons ce problème de prédiction, un problème de
<strong>regression</strong>.</p>
<p>Si <code class="docutils literal notranslate"><span class="pre">y</span></code> est une variable <strong>discrète</strong>, comme par exemple l’espèce de pinguoin,
nous appelons ce problème, un problème de <strong>classification</strong>.</p>
<p>Donc à partir de ces données, nous aimerions apprendre une fonction de
prédiction <code class="docutils literal notranslate"><span class="pre">f()</span></code>. La définition de telles fonctions sont le résultat de
recherche fondamentale dans le domaine de l’apprentissage automatique. Nous
allons présenter ces différentes fonctions dans la suite de ce livre.</p>
<p>Mais afin d’illustrer le principe d’une fonction de prédiction, nous
pourrions venir avec notre propre fonction de prédiction, basée sur une
intuition. En regardant le graphique représentant notre variable d’entrée et
notre variable de sortie, nous pourrions calculer une relation moyenne entre
la longueur d’aileron et la masse corporelle.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">relation_X_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="s2">&quot;Longueur Aileron (mm)&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span>
<span class="n">relation_X_y</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0.04898871471403136
</pre></div>
</div>
</div>
</div>
<p>Maintenant nous pouvons utiliser cette relation pour prédire la masse :
nous sommes entrain de d’utiliser le fameux “produit en croix”. Donc,
essayons de prédire la masse du premier pingouin dans notre dataset.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">masse_premier_pinguoin</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">relation_X_y</span>
<span class="n">masse_premier_pinguoin</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>3694.728491175498
</pre></div>
</div>
</div>
</div>
<p>Nous pouvons même estimer la différence avec sa masse réelle.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span>
    <span class="sa">f</span><span class="s2">&quot;Masse réelle: </span><span class="si">{</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> grammes</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="sa">f</span><span class="s2">&quot;Masse prédite: </span><span class="si">{</span><span class="n">masse_premier_pinguoin</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> grammes</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="sa">f</span><span class="s2">&quot;Différence: </span><span class="si">{</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">masse_premier_pinguoin</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> grammes&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Masse réelle: 3750.0 grammes
Masse prédite: 3694.73 grammes
Différence: 55.27 grammes
</pre></div>
</div>
</div>
</div>
<p>Pour pousser notre exemple plus proche de notre définition mathématique,
nous pouvons utiliser une fonction Python pour apprendre la relation et
une autre fonction Python pour prédire la masse.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">apprendre_relation</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apprendre une relation moyenne entre la longueur d&#39;aileron et la masse</span>
<span class="sd">    corporelle des pinguoins.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="s2">&quot;Longueur Aileron (mm)&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">relation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Function de predisant la masse corporelle d&#39;un pingouin à partir de</span>
<span class="sd">    la longueur de son aileron.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="s2">&quot;Longueur Aileron (mm)&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">relation</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;Masse Corporelle (g)&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">relation</span> <span class="o">=</span> <span class="n">apprendre_relation</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">relation</span><span class="p">)</span>
<span class="n">predictions</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>0      3694.728491
1      3796.792814
2      3980.508595
3      3939.682866
4      3878.444273
          ...     
337    4225.462971
338    4123.398648
339    3939.682866
340    4286.701564
341    4041.747189
Name: Masse Corporelle (g), Length: 342, dtype: float64
</pre></div>
</div>
</div>
</div>
<p>Nous pouvons même calculer l’erreur (absolue) de nos prédictions.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">erreur_absolue_moyenne</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">predictions</span> <span class="o">-</span> <span class="n">y</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Erreur absolue moyenne: </span><span class="si">{</span><span class="n">erreur_absolue_moyenne</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> grammes&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Erreur absolue moyenne: 467.40 grammes
</pre></div>
</div>
</div>
</div>
<p>Notre stratégie d’apprentissage nous permet d’obtenir un modèle prédictif
qui commet en moyenne une erreur de 467 grammes sur le même jeu de données.
Nous pouvons également représenter graphiquement la relation que nous avons
appris.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">donnees</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">donnees</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">donnees</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
    <span class="n">X</span><span class="p">[</span><span class="s2">&quot;Longueur Aileron (mm)&quot;</span><span class="p">],</span>
    <span class="n">predictions</span><span class="p">,</span>
    <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
    <span class="n">linewidth</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Notre fonction&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Notre premier modèle prédictif&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/file_00_22_0.png" src="../_images/file_00_22_0.png" />
</div>
</div>
<p>Il est a noté que nous ne devrions pas apprendre et evaluer notre fonction de
prédiction sur les mêmes données. Le score obtenu est potentiellement trop
optimiste. Nous allons revenir sur ce point à la fin de cette section où nous
présenterons les outils et la manière d’évaluer correctement un modèle
prédictif.</p>
</div>
<div class="section" id="introduction-a-l-interface-de-programmation-de-scikit-learn">
<h2>Introduction à l’interface de programmation de <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code><a class="headerlink" href="#introduction-a-l-interface-de-programmation-de-scikit-learn" title="Permalink to this headline">¶</a></h2>
<p>Dans cette section, nous allons présenter succintement l’interface de
programmation de <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code>. Nous utiliserons cette interface dans les
sections et chapitres suivants lorsque nous présenterons les différents types
de modèles prédictifs.</p>
<p>Afin de présenter cette interface, nous allons créer nous même un modèle
prédictif qui pourrait être utilisé en conjonction avec tous les outils de
<code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code>. Nous allons également argumenté les choix d’interface
réalisés par les développeurs de <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> historiquement.</p>
<p>Dans la précédente section, nous avons vu constaté que l’apprentissage
automatique était consititué de deux étapes : une <strong>étape d’apprentissage</strong>
pour obtenir la fonction de prédiction optimale et une <strong>étape de
prédiction</strong> ou nous avons réutiliser la relation appris pour prédire la
masse corporelle.</p>
<p>Il advient que nous pourrions utiliser une classe Python pour stocker à
l’intérieur de cette instance d’objet les informations utilisées pour la
prédiction. Nous aurions seulement besoin donc d’exposer une méthode pour
effectuer l’apprentissage et une méthode pour prédire.</p>
<p>En résumé, nous pouvons créer la classe suivante :</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="kn">import</span> <span class="n">BaseEstimator</span>


<span class="k">class</span> <span class="nc">ModelePredictif</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coef_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="s2">&quot;Longueur Aileron (mm)&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="s2">&quot;Longueur Aileron (mm)&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">relation</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;Masse Corporelle (g)&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Dans <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code>, un modèle prédictif (également appelé estimateur)
possède deux méthodes : <code class="docutils literal notranslate"><span class="pre">fit</span></code> et <code class="docutils literal notranslate"><span class="pre">predict</span></code>. La première est en charge
d’apprendre les éléments nécessaires à la prédiction. De plus cette méthode
retourne <code class="docutils literal notranslate"><span class="pre">self</span></code> pour permettre de chainer les appels. La deuxième méthode est
en charge de prédire. Nous pouvons mettre en place notre class de la façon
suivante :</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">modele</span> <span class="o">=</span> <span class="n">ModelePredictif</span><span class="p">()</span>
<span class="n">modele</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">modele</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<span class="n">erreur_absolue_moyenne</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">predictions</span> <span class="o">-</span> <span class="n">y</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Erreur absolue moyenne: </span><span class="si">{</span><span class="n">erreur_absolue_moyenne</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> grammes&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Erreur absolue moyenne: 467.40 grammes
</pre></div>
</div>
</div>
</div>
<p>En plus des méthodes <code class="docutils literal notranslate"><span class="pre">fit</span></code> et <code class="docutils literal notranslate"><span class="pre">predict</span></code>, <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> expose une méthode
<code class="docutils literal notranslate"><span class="pre">score</span></code> qui permet de calculer le score de prédiction.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ModelePredictif</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coef_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="s2">&quot;Longueur Aileron (mm)&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="s2">&quot;Longueur Aileron (mm)&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="n">relation</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s2">&quot;Masse Corporelle (g)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">predictions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">predictions</span> <span class="o">-</span> <span class="n">y</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<p>Nous pourrions donc simplifier notre code précédent de la manière suivante :</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Erreur absolue moyenne: </span><span class="si">{</span><span class="n">ModelePredictif</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> grammes&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Erreur absolue moyenne: 467.40 grammes
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="evaluation-de-notre-modele-predictif">
<h2>Evaluation de notre modèle prédictif<a class="headerlink" href="#evaluation-de-notre-modele-predictif" title="Permalink to this headline">¶</a></h2>
<p>Dans la section précédente, nous avons calculé l’erreur absolue moyenne sur
le même jeu de données utilisé pendant l’apprentissage.</p>
<p>Cependant cette approche est réellement problématique. Nous aurions pu créer
un modèle prédictif qui ne prend pas en compte les données d’apprentissage et
qui mémorise tous les échantillons d’apprentissage. Nous aurions alors donc
obtenu une erreur de prédiction de 0 grammes. En revance, en utilisant le
même modèle sur un nouveau dataset pour seulement effectuer de la prédiction,
nous aurions alors obtenu une erreur plus importante.</p>
<p>C’est pour cela qu’il est nécessaire d’évaluer un modèle prédictif sur des
données qui ne sont pas dans le jeu d’apprentissage. L’erreur obtenu sur le
jeu d’apprentissage est appelé l’<strong>erreur empirique</strong> alors que l’erreur
obtenu sur le jeu de test est appelé l’<strong>erreur de généralisation</strong>. En
apprentissage automatique, les méthodes essayent en général de minimiser
l’erreur empirique en espérant que l’erreur de généralisation soit minimale
également.</p>
<p>Nous pouvons utiliser notre jeu de données original et le séparer en deux
jeux de données afin de calculer les deux types d’erreurs. <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code>
fournit une fonction <code class="docutils literal notranslate"><span class="pre">train_test_split</span></code> qui permet de séparer un jeu de
données.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">train_test_split</span>

<span class="n">X_apprentissage</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_apprentissage</span><span class="p">,</span> <span class="n">y_test</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span>
    <span class="n">X</span><span class="p">,</span>
    <span class="n">y</span><span class="p">,</span>
    <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">test_size</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span>
    <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>La sélection de ces jeux de données est faite de manière aléatoire. Le
paramètre <code class="docutils literal notranslate"><span class="pre">random_state</span></code> permet d’obtenir une séparation déterministique même
si un procédure aléatoire est utilisée. De plus, le paramètre <code class="docutils literal notranslate"><span class="pre">test_size</span></code>
permet de définir la proportion de données qui seront utilisées pour le jeu
de test.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">modele</span> <span class="o">=</span> <span class="n">ModelePredictif</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_apprentissage</span><span class="p">,</span> <span class="n">y_apprentissage</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Erreur empirique: </span><span class="si">{</span><span class="n">modele</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_apprentissage</span><span class="p">,</span> <span class="n">y_apprentissage</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> grammes&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Erreur de généralisation: </span><span class="si">{</span><span class="n">modele</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> grammes&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Erreur empirique: 473.92 grammes
Erreur de généralisation: 441.63 grammes
</pre></div>
</div>
</div>
</div>
<p>Nous observons que notre modèle performe moins bien sur le jeu de test que
sur le jeu d’apprentissage.</p>
<p>La comparaison des erreurs empérique et de généralisation permette de
connaître de savoir si un modèle sous-apprend, généralise ou sur-apprend. Le
sur-apprentissage est caractérisé par une erreur de géralisation plus élevée
que l’erreur empirique. La plage de générasation est définie par lorsque la
différence entre l’erreur de généralisation et l’erreur empirique est assez
minimale. Un modèle sous-apprentissage est caractérisé par une erreur de
généralisation élevée mais également une erreur empirique élevée.</p>
<p>Bien que nous ayons maintenant une idée concernant la capacité de notre
modèle à prédire sur un set indépendant de celui d’apprentissage, nous ne
pouvons pas réellement savoir si la différence entre les erreurs empirique et
de généralisation est suffisante pour déterminer si un modèle est en
sous-apprentissage ou en sur-apprentissage ou généralise. En effet, puisque
la procédure de séparation des jeux de données est aléatoire, nous devrions
réaliser plusieurs essais pour obtenir une distribution des erreurs et
evaluer si les différences sont suffisantes.</p>
<p>Ces essais répétés sont dénommés <strong>cross-validation</strong>. <code class="docutils literal notranslate"><span class="pre">scikit-learn</span></code> fournit
une fonction <code class="docutils literal notranslate"><span class="pre">cross_validate</span></code> permettant de réaliser ces essais. Il existe
plusieurs méthodes de cross-validation. Nous allons utiliser la méthode
<strong>k-fold</strong> qui permet de séparer un jeu de données en <span class="math notranslate nohighlight">\(k\)</span> sous-ensembles. A
chaque itération de la cross-validation, un des <span class="math notranslate nohighlight">\(k\)</span> sous-ensembles est
utilisé pour évaluer le modèle alors que les autres sous-ensembles sont
utilisés pour l’apprentissage.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">cross_validate</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">KFold</span>

<span class="n">cv</span> <span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">cv_resultats</span> <span class="o">=</span> <span class="n">cross_validate</span><span class="p">(</span>
    <span class="n">modele</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;neg_mean_absolute_error&quot;</span><span class="p">,</span> <span class="n">return_train_score</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
<span class="n">cv_resultats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">cv_resultats</span><span class="p">)</span>
<span class="n">cv_resultats</span><span class="p">[[</span><span class="s2">&quot;train_error&quot;</span><span class="p">,</span> <span class="s2">&quot;test_error&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="n">cv_resultats</span><span class="p">[</span>
    <span class="p">[</span><span class="s2">&quot;train_score&quot;</span><span class="p">,</span> <span class="s2">&quot;test_score&quot;</span><span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cv_resultats</span><span class="p">[[</span><span class="s2">&quot;train_error&quot;</span><span class="p">,</span> <span class="s2">&quot;test_error&quot;</span><span class="p">]]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>train_error</th>
      <th>test_error</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>473.915845</td>
      <td>441.630137</td>
    </tr>
    <tr>
      <th>1</th>
      <td>467.033573</td>
      <td>468.859994</td>
    </tr>
    <tr>
      <th>2</th>
      <td>449.924529</td>
      <td>537.826237</td>
    </tr>
    <tr>
      <th>3</th>
      <td>473.929172</td>
      <td>441.101644</td>
    </tr>
    <tr>
      <th>4</th>
      <td>472.229617</td>
      <td>447.949854</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Cross-validation nous permet donc d’obtenir plusieurs estimations de nos
erreurs. Nous pouvons même répéter l’opération plusieurs fois pour obtenir
des distributions d’erreurs que nous pourrons visualiser.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="kn">import</span> <span class="n">RepeatedKFold</span>

<span class="n">cv</span> <span class="o">=</span> <span class="n">RepeatedKFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">cv_resultats</span> <span class="o">=</span> <span class="n">cross_validate</span><span class="p">(</span>
    <span class="n">modele</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s2">&quot;neg_mean_absolute_error&quot;</span><span class="p">,</span> <span class="n">return_train_score</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
<span class="n">cv_resultats</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">cv_resultats</span><span class="p">)</span>
<span class="n">cv_resultats</span><span class="p">[[</span><span class="s2">&quot;train_error&quot;</span><span class="p">,</span> <span class="s2">&quot;test_error&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="n">cv_resultats</span><span class="p">[</span>
    <span class="p">[</span><span class="s2">&quot;train_score&quot;</span><span class="p">,</span> <span class="s2">&quot;test_score&quot;</span><span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">cv_resultats</span><span class="p">[[</span><span class="s2">&quot;train_error&quot;</span><span class="p">,</span> <span class="s2">&quot;test_error&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">bins</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Erreur moyenne absolue (grammes)&quot;</span><span class="p">)</span>
<span class="n">_</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
    <span class="sa">f</span><span class="s2">&quot;Distribution des erreurs</span><span class="se">\n</span><span class="s2">Std. dev. variable cible: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> (g)&quot;</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../_images/file_00_41_0.png" src="../_images/file_00_41_0.png" />
</div>
</div>
<p>Il est toujours bon de mettre en perspective l’erreur moyenne obtenue avec
la variable cible. En effet, notre modèle commet une erreur de 450 grammes
sur notre données alors que la standard deviation de la variable cible est de
800 grammes. Notre modèle n’est donc pas un très bon modèle.</p>
<p>Quand on compare les distributions, nous regardons si ces distributions se
chevauchent. Si les distributions se chevauchent et que leur moyenne et leur
standard déviation sont proches, alors le modèle est capable de généraliser.
Une différence entre les distributions nous permet de conclure sur le sous-
ou sur-apprentissage. En revanche, quand les standard déviations sont trop
larges, ceci est souvent lié à un manque de données et il sera difficile de
tirer des conclusions.</p>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./chapter_00"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            



<div class='prev-next-bottom'>
    
    <div id="prev">
        <a class="left-prev" href="chapter_00_intro.html" title="previous page">
            <i class="prevnext-label fas fa-angle-left"></i>
            <div class="prevnext-info">
                <p class="prevnext-label">previous</p>
                <p class="prevnext-title">Apprentisage automatique supervisé</p>
            </div>
        </a>
    </div>
     <div id="next">
        <a class="right-next" href="file_01.html" title="next page">
            <div class="prevnext-info">
                <p class="prevnext-label">next</p>
                <p class="prevnext-title">Famille des modèles paramétriques</p>
            </div>
            <i class="prevnext-label fas fa-angle-right"></i>
        </a>
     </div>

</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By Cédric Lemaître<br/>
        
            &copy; Copyright 2021.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../_static/js/index.1c5a1a01449ed65a7b51.js"></script>

  
  </body>
</html>